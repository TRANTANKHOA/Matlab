<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Stan: stan::model Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Stan
   &#160;<span id="projectnumber">2.9.0</span>
   </div>
   <div id="projectbrief">probability, sampling &amp; optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacestan.html">stan</a></li><li class="navelem"><a class="el" href="namespacestan_1_1model.html">model</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stan::model Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>For compiling models.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template structure for an index list consisting of a head and tail index.  <a href="structstan_1_1model_1_1cons__index__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1index__max.html">index_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an indexing from the start of a container to a specified maximum index (inclusive).  <a href="structstan_1_1model_1_1index__max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1index__min.html">index_min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an indexing from a minimum index (inclusive) to the end of a container.  <a href="structstan_1_1model_1_1index__min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1index__min__max.html">index_min_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an indexing from a minimum index (inclusive) to a maximum index (inclusive).  <a href="structstan_1_1model_1_1index__min__max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1index__multi.html">index_multi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an indexing consisting of multiple indexes.  <a href="structstan_1_1model_1_1index__multi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1index__omni.html">index_omni</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an indexing that consists of all indexes for a container.  <a href="structstan_1_1model_1_1index__omni.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an indexing consisting of a single index.  <a href="structstan_1_1model_1_1index__uni.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1model__functional.html">model_functional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for an empty (size zero) index list.  <a href="structstan_1_1model_1_1nil__index__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1model_1_1prob__grad.html">prob_grad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classstan_1_1model_1_1prob__grad.html" title="The prob_grad class represents the basic parameter holders for a model. ">prob_grad</a></code> class represents the basic parameter holders for a model.  <a href="classstan_1_1model_1_1prob__grad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return.html">rvalue_return</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to calculate return value for <code><a class="el" href="namespacestan_1_1model.html#af8c4d8320edab91bdc7872b161bb1590" title="Return the result of indexing a specified value with a nil index list, which just returns the value...">model::rvalue()</a></code> for the container or scalar type and index list type specified in the template parameters.  <a href="structstan_1_1model_1_1rvalue__return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01_c_00_01nil__index__list_01_4.html">rvalue_return&lt; C, nil_index_list &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class specialization for nil indexes, which provide the container type as the return type.  <a href="structstan_1_1model_1_1rvalue__return_3_01_c_00_01nil__index__list_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_011_00_01_eigen_1_1_dynami20d2ba16fb3fd569bcc70451a712c570.html">rvalue_return&lt; Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt;,                                                                                                                                                                                   cons_index_list&lt; index_uni, nil_index_list &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class specialization for an Eigen row vector and one single index.  <a href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_011_00_01_eigen_1_1_dynami20d2ba16fb3fd569bcc70451a712c570.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_01ed9772bbb598ef18e1cc9d9088e9d572.html">rvalue_return&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;,                                                                                                                                                                                   cons_index_list&lt; index_uni, nil_index_list &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class specialization for an Eigen vector and one single index.  <a href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_01ed9772bbb598ef18e1cc9d9088e9d572.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_0114a78c50178e180aa3b3a2eedac057a8.html">rvalue_return&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;,                                                                                                                                                                                   cons_index_list&lt; I,                                                                                                                                                                                                                                                                                                                   cons_index_list&lt; index_uni,                                                                                                                                                                                                                                                                                                                                                                                                                                                   nil_index_list &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for an Eigen matrix with one multiple index followed by one single index.  <a href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_0114a78c50178e180aa3b3a2eedac057a8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_013557ee4de807e69b7fabf62cc8b14a74.html">rvalue_return&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;,                                                                                                                                                                                   cons_index_list&lt; I1,                                                                                                                                                                                                                                                                                                                   cons_index_list&lt; I2,                                                                                                                                                                                                                                                                                                                                                                                                                                                   nil_index_list &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for an Eigen matrix and two multiple indexes.  <a href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_013557ee4de807e69b7fabf62cc8b14a74.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_017736e614991ad2da6d7d0cdc6395ca61.html">rvalue_return&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;,                                                                                                                                                                                   cons_index_list&lt; index_uni,                                                                                                                                                                                                                                                                                                                   cons_index_list&lt; I,                                                                                                                                                                                                                                                                                                                                                                                                                                                   nil_index_list &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for an Eigen matrix with one single index followed by one multiple index.  <a href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_017736e614991ad2da6d7d0cdc6395ca61.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_011883086d51db77b7ec0df909e388fd30.html">rvalue_return&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;,                                                                                                                                                                                   cons_index_list&lt; index_uni,                                                                                                                                                                                                                                                                                                                   cons_index_list&lt; index_uni,                                                                                                                                                                                                                                                                                                                                                                                                                                                   nil_index_list &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for an Eigen matrix with two single indexes.  <a href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_011883086d51db77b7ec0df909e388fd30.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_01d5a33fb9760d7a1f05fe3706b980093e.html">rvalue_return&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;,                                                                                                                                                                                   cons_index_list&lt; index_uni, nil_index_list &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class specialization for an Eigen matrix and one single index.  <a href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_eigen_1_1_dynamic_00_01d5a33fb9760d7a1f05fe3706b980093e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_018ec95e7812ac507c083ba3a19310d2f9.html">rvalue_return&lt; Eigen::Matrix&lt; T, R, C &gt;,                                                                                                                                                                                   cons_index_list&lt; I, nil_index_list &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class specialization for an Eigen matrix, vector or rwo vector and one multiple index.  <a href="structstan_1_1model_1_1rvalue__return_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_018ec95e7812ac507c083ba3a19310d2f9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01std_1_1vector_3_01_c_01_4_00_01cons__index__list_3_01_i_00_01_l_01_4_01_4.html">rvalue_return&lt; std::vector&lt; C &gt;, cons_index_list&lt; I, L &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for a standard vector whose index list starts with a multiple index.  <a href="structstan_1_1model_1_1rvalue__return_3_01std_1_1vector_3_01_c_01_4_00_01cons__index__list_3_01_i_00_01_l_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1model_1_1rvalue__return_3_01std_1_1vector_3_01_c_01_4_00_01cons__index__list_3_01index__uni_00_01_l_01_4_01_4.html">rvalue_return&lt; std::vector&lt; C &gt;, cons_index_list&lt; index_uni, L &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for a standard vector whose index list starts with a single index.  <a href="structstan_1_1model_1_1rvalue__return_3_01std_1_1vector_3_01_c_01_4_00_01cons__index__list_3_01index__uni_00_01_l_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6084abaf50ba3f9fbc1e0a7461d85319"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6084abaf50ba3f9fbc1e0a7461d85319"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a6084abaf50ba3f9fbc1e0a7461d85319">deep_copy</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6084abaf50ba3f9fbc1e0a7461d85319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument as a constant reference.  <a href="#a6084abaf50ba3f9fbc1e0a7461d85319">More...</a><br /></td></tr>
<tr class="separator:a6084abaf50ba3f9fbc1e0a7461d85319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85308234fda43fcf61b398887e12e3de"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C&gt; </td></tr>
<tr class="memitem:a85308234fda43fcf61b398887e12e3de"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a85308234fda43fcf61b398887e12e3de">deep_copy</a> (const Eigen::Matrix&lt; T, R, C &gt; &amp;a)</td></tr>
<tr class="memdesc:a85308234fda43fcf61b398887e12e3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the specified matrix, vector, or row vector.  <a href="#a85308234fda43fcf61b398887e12e3de">More...</a><br /></td></tr>
<tr class="separator:a85308234fda43fcf61b398887e12e3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dd9a8c2e34a21493d17e4c911dac16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3dd9a8c2e34a21493d17e4c911dac16"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#af3dd9a8c2e34a21493d17e4c911dac16">deep_copy</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:af3dd9a8c2e34a21493d17e4c911dac16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of the specified standard vector.  <a href="#af3dd9a8c2e34a21493d17e4c911dac16">More...</a><br /></td></tr>
<tr class="separator:af3dd9a8c2e34a21493d17e4c911dac16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278284087b9a82fd76dd8f6b78a262d9"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T &gt; </td></tr>
<tr class="memitem:a278284087b9a82fd76dd8f6b78a262d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a278284087b9a82fd76dd8f6b78a262d9">cons_list</a> (const I &amp;idx1, const T &amp;t)</td></tr>
<tr class="separator:a278284087b9a82fd76dd8f6b78a262d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c059a1718ccb6220b7f04d87cb6c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a43c059a1718ccb6220b7f04d87cb6c81">index_list</a> ()</td></tr>
<tr class="separator:a43c059a1718ccb6220b7f04d87cb6c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97c001e5692ddbc3d49b16e0f15f0c1"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:aa97c001e5692ddbc3d49b16e0f15f0c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aa97c001e5692ddbc3d49b16e0f15f0c1">index_list</a> (const I &amp;idx)</td></tr>
<tr class="separator:aa97c001e5692ddbc3d49b16e0f15f0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f85816f7cdf1ccd08410e136fee1d37"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:a3f85816f7cdf1ccd08410e136fee1d37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I1, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I2, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a3f85816f7cdf1ccd08410e136fee1d37">index_list</a> (const I1 &amp;idx1, const I2 &amp;idx2)</td></tr>
<tr class="separator:a3f85816f7cdf1ccd08410e136fee1d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef6ff4159e0d5ae26c70a531bfdc0af"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 , typename I3 &gt; </td></tr>
<tr class="memitem:a3ef6ff4159e0d5ae26c70a531bfdc0af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I1, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I2, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I3, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a3ef6ff4159e0d5ae26c70a531bfdc0af">index_list</a> (const I1 &amp;idx1, const I2 &amp;idx2, const I3 &amp;idx3)</td></tr>
<tr class="separator:a3ef6ff4159e0d5ae26c70a531bfdc0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0b8ef16725f1195f73e08e116017e3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7f0b8ef16725f1195f73e08e116017e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a7f0b8ef16725f1195f73e08e116017e3">assign</a> (T &amp;x, const <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &amp;, const U &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a7f0b8ef16725f1195f73e08e116017e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified scalar reference under the specified indexing to the specified scalar value.  <a href="#a7f0b8ef16725f1195f73e08e116017e3">More...</a><br /></td></tr>
<tr class="separator:a7f0b8ef16725f1195f73e08e116017e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f71b06cde1e977368b20d1d400c6480"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9f71b06cde1e977368b20d1d400c6480"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a9f71b06cde1e977368b20d1d400c6480">assign</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idxs, const U &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a9f71b06cde1e977368b20d1d400c6480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen vector at the specified single index to the specified value.  <a href="#a9f71b06cde1e977368b20d1d400c6480">More...</a><br /></td></tr>
<tr class="separator:a9f71b06cde1e977368b20d1d400c6480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d30982b96914bc5b95cc8089f2ce565"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4d30982b96914bc5b95cc8089f2ce565"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a4d30982b96914bc5b95cc8089f2ce565">assign</a> (Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idxs, const U &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a4d30982b96914bc5b95cc8089f2ce565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen vector at the specified single index to the specified value.  <a href="#a4d30982b96914bc5b95cc8089f2ce565">More...</a><br /></td></tr>
<tr class="separator:a4d30982b96914bc5b95cc8089f2ce565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb876f8c3abde7ff2bdeb5038c43d6f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I , typename U &gt; </td></tr>
<tr class="memitem:a8bb876f8c3abde7ff2bdeb5038c43d6f"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a8bb876f8c3abde7ff2bdeb5038c43d6f">assign</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idxs, const Eigen::Matrix&lt; U, Eigen::Dynamic, 1 &gt; &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a8bb876f8c3abde7ff2bdeb5038c43d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen vector at the specified multiple index to the specified value.  <a href="#a8bb876f8c3abde7ff2bdeb5038c43d6f">More...</a><br /></td></tr>
<tr class="separator:a8bb876f8c3abde7ff2bdeb5038c43d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9490a4a5e36acddfc2384825ecb9721b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I , typename U &gt; </td></tr>
<tr class="memitem:a9490a4a5e36acddfc2384825ecb9721b"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a9490a4a5e36acddfc2384825ecb9721b">assign</a> (Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idxs, const Eigen::Matrix&lt; U, 1, Eigen::Dynamic &gt; &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a9490a4a5e36acddfc2384825ecb9721b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen row vector at the specified multiple index to the specified value.  <a href="#a9490a4a5e36acddfc2384825ecb9721b">More...</a><br /></td></tr>
<tr class="separator:a9490a4a5e36acddfc2384825ecb9721b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b732d3abb2cb830e460b511e738a3cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7b732d3abb2cb830e460b511e738a3cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a7b732d3abb2cb830e460b511e738a3cd">assign</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idxs, const Eigen::Matrix&lt; U, 1, Eigen::Dynamic &gt; &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a7b732d3abb2cb830e460b511e738a3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen matrix at the specified single index to the specified row vector value.  <a href="#a7b732d3abb2cb830e460b511e738a3cd">More...</a><br /></td></tr>
<tr class="separator:a7b732d3abb2cb830e460b511e738a3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07159284d6272c14cdb5509c616cdad8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I , typename U &gt; </td></tr>
<tr class="memitem:a07159284d6272c14cdb5509c616cdad8"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a07159284d6272c14cdb5509c616cdad8">assign</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idxs, const Eigen::Matrix&lt; U, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a07159284d6272c14cdb5509c616cdad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen matrix at the specified multiple index to the specified matrix value.  <a href="#a07159284d6272c14cdb5509c616cdad8">More...</a><br /></td></tr>
<tr class="separator:a07159284d6272c14cdb5509c616cdad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230e918a853477b72dc274d20467a6c2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a230e918a853477b72dc274d20467a6c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a230e918a853477b72dc274d20467a6c2">assign</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;idxs, const U &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a230e918a853477b72dc274d20467a6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen matrix at the specified pair of single indexes to the specified scalar value.  <a href="#a230e918a853477b72dc274d20467a6c2">More...</a><br /></td></tr>
<tr class="separator:a230e918a853477b72dc274d20467a6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3003870fefbc179d776ea3207d14f12"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I , typename U &gt; </td></tr>
<tr class="memitem:af3003870fefbc179d776ea3207d14f12"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#af3003870fefbc179d776ea3207d14f12">assign</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;idxs, const Eigen::Matrix&lt; U, 1, Eigen::Dynamic &gt; &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:af3003870fefbc179d776ea3207d14f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen matrix at the specified single and multiple index to the specified row vector.  <a href="#af3003870fefbc179d776ea3207d14f12">More...</a><br /></td></tr>
<tr class="separator:af3003870fefbc179d776ea3207d14f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56779293f41b1efa31c8da32e2b0f9b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I , typename U &gt; </td></tr>
<tr class="memitem:a56779293f41b1efa31c8da32e2b0f9b1"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a56779293f41b1efa31c8da32e2b0f9b1">assign</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;idxs, const Eigen::Matrix&lt; U, Eigen::Dynamic, 1 &gt; &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a56779293f41b1efa31c8da32e2b0f9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen matrix at the specified multiple and single index to the specified vector.  <a href="#a56779293f41b1efa31c8da32e2b0f9b1">More...</a><br /></td></tr>
<tr class="separator:a56779293f41b1efa31c8da32e2b0f9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f637db1c94e950ba4642ba2c46afb9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I1 , typename I2 , typename U &gt; </td></tr>
<tr class="memitem:aa9f637db1c94e950ba4642ba2c46afb9"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if_c&lt; boost::is_same&lt; I1, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;::value||boost::is_same&lt; I2, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aa9f637db1c94e950ba4642ba2c46afb9">assign</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I1, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I2, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;idxs, const Eigen::Matrix&lt; U, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:aa9f637db1c94e950ba4642ba2c46afb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified Eigen matrix at the specified pair of multiple indexes to the specified matrix.  <a href="#aa9f637db1c94e950ba4642ba2c46afb9">More...</a><br /></td></tr>
<tr class="separator:aa9f637db1c94e950ba4642ba2c46afb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3916ad65b7d9d8e0972fb63860f7013d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:a3916ad65b7d9d8e0972fb63860f7013d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a3916ad65b7d9d8e0972fb63860f7013d">assign</a> (std::vector&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, L &gt; &amp;idxs, const U &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a3916ad65b7d9d8e0972fb63860f7013d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified array (standard vector) at the specified index list beginning with a single index to the specified value.  <a href="#a3916ad65b7d9d8e0972fb63860f7013d">More...</a><br /></td></tr>
<tr class="separator:a3916ad65b7d9d8e0972fb63860f7013d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec6a7e4faad53ff63e31850bccd8fcd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I , typename L , typename U &gt; </td></tr>
<tr class="memitem:a3ec6a7e4faad53ff63e31850bccd8fcd"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a3ec6a7e4faad53ff63e31850bccd8fcd">assign</a> (std::vector&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, L &gt; &amp;idxs, const std::vector&lt; U &gt; &amp;y, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a3ec6a7e4faad53ff63e31850bccd8fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the specified array (standard vector) at the specified index list beginning with a multiple index to the specified value.  <a href="#a3ec6a7e4faad53ff63e31850bccd8fcd">More...</a><br /></td></tr>
<tr class="separator:a3ec6a7e4faad53ff63e31850bccd8fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c4d8320edab91bdc7872b161bb1590"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8c4d8320edab91bdc7872b161bb1590"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#af8c4d8320edab91bdc7872b161bb1590">rvalue</a> (const T &amp;c, const <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &amp;, const char *=&quot;&quot;, int=0)</td></tr>
<tr class="memdesc:af8c4d8320edab91bdc7872b161bb1590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing a specified value with a nil index list, which just returns the value.  <a href="#af8c4d8320edab91bdc7872b161bb1590">More...</a><br /></td></tr>
<tr class="separator:af8c4d8320edab91bdc7872b161bb1590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa675158b2ee44a54362c2b39cbf59c58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa675158b2ee44a54362c2b39cbf59c58"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aa675158b2ee44a54362c2b39cbf59c58">rvalue</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:aa675158b2ee44a54362c2b39cbf59c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen vector with a sequence containing one single index, returning a scalar.  <a href="#aa675158b2ee44a54362c2b39cbf59c58">More...</a><br /></td></tr>
<tr class="separator:aa675158b2ee44a54362c2b39cbf59c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce39dae68c631e5131ef0e5fc37f97d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ce39dae68c631e5131ef0e5fc37f97d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a4ce39dae68c631e5131ef0e5fc37f97d">rvalue</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a4ce39dae68c631e5131ef0e5fc37f97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen row vector with a sequence containing one single index, returning a scalar.  <a href="#a4ce39dae68c631e5131ef0e5fc37f97d">More...</a><br /></td></tr>
<tr class="separator:a4ce39dae68c631e5131ef0e5fc37f97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7eb76075d6d1084507c57872d41827"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:acb7eb76075d6d1084507c57872d41827"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#acb7eb76075d6d1084507c57872d41827">rvalue</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:acb7eb76075d6d1084507c57872d41827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen vector with a sequence containing one multiple index, returning a vector.  <a href="#acb7eb76075d6d1084507c57872d41827">More...</a><br /></td></tr>
<tr class="separator:acb7eb76075d6d1084507c57872d41827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96fa8f4cb88877349ca79caf562404f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:aa96fa8f4cb88877349ca79caf562404f"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aa96fa8f4cb88877349ca79caf562404f">rvalue</a> (const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;rv, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:aa96fa8f4cb88877349ca79caf562404f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen row vector with a sequence containing one multiple index, returning a row vector.  <a href="#aa96fa8f4cb88877349ca79caf562404f">More...</a><br /></td></tr>
<tr class="separator:aa96fa8f4cb88877349ca79caf562404f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6180f5d0443f3be7a66e60cf5e596bfc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6180f5d0443f3be7a66e60cf5e596bfc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a6180f5d0443f3be7a66e60cf5e596bfc">rvalue</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;a, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a6180f5d0443f3be7a66e60cf5e596bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen matrix with a sequence consisting of one single index, returning a row vector.  <a href="#a6180f5d0443f3be7a66e60cf5e596bfc">More...</a><br /></td></tr>
<tr class="separator:a6180f5d0443f3be7a66e60cf5e596bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af583f433425d3b9f59dc3f7d4d008e51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:af583f433425d3b9f59dc3f7d4d008e51"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#af583f433425d3b9f59dc3f7d4d008e51">rvalue</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;a, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:af583f433425d3b9f59dc3f7d4d008e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen matrix with a sequence consisting of a one multiple index, returning a matrix.  <a href="#af583f433425d3b9f59dc3f7d4d008e51">More...</a><br /></td></tr>
<tr class="separator:af583f433425d3b9f59dc3f7d4d008e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9079b2f7194ad6c26a3a6d0de929a7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9079b2f7194ad6c26a3a6d0de929a7b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aa9079b2f7194ad6c26a3a6d0de929a7b">rvalue</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;a, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:aa9079b2f7194ad6c26a3a6d0de929a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen matrix with a sequence consisting of two single indexes, returning a scalar.  <a href="#aa9079b2f7194ad6c26a3a6d0de929a7b">More...</a><br /></td></tr>
<tr class="separator:aa9079b2f7194ad6c26a3a6d0de929a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bc4a3239513de365fa9605d42cdd1b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:aa0bc4a3239513de365fa9605d42cdd1b"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aa0bc4a3239513de365fa9605d42cdd1b">rvalue</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;a, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:aa0bc4a3239513de365fa9605d42cdd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen matrix with a sequence consisting of a single index and multiple index, returning a row vector.  <a href="#aa0bc4a3239513de365fa9605d42cdd1b">More...</a><br /></td></tr>
<tr class="separator:aa0bc4a3239513de365fa9605d42cdd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7874bb360c679dc3bf53bcb09a3e346"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I &gt; </td></tr>
<tr class="memitem:ad7874bb360c679dc3bf53bcb09a3e346"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_same&lt; I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ad7874bb360c679dc3bf53bcb09a3e346">rvalue</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;a, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:ad7874bb360c679dc3bf53bcb09a3e346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen matrix with a sequence consisting of a multiple index and a single index, returning a vector.  <a href="#ad7874bb360c679dc3bf53bcb09a3e346">More...</a><br /></td></tr>
<tr class="separator:ad7874bb360c679dc3bf53bcb09a3e346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62e0fdc3aa8908c0c354f650dbda201"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ad62e0fdc3aa8908c0c354f650dbda201"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if_c&lt; boost::is_same&lt; I1, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;::value||boost::is_same&lt; I2, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a> &gt;::value, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ad62e0fdc3aa8908c0c354f650dbda201">rvalue</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;a, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I1, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I2, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:ad62e0fdc3aa8908c0c354f650dbda201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified Eigen matrix with a sequence consisting of a pair o multiple indexes, returning a a matrix.  <a href="#ad62e0fdc3aa8908c0c354f650dbda201">More...</a><br /></td></tr>
<tr class="separator:ad62e0fdc3aa8908c0c354f650dbda201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53b57a1e4c19b52ba7dc461c3597a03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L &gt; </td></tr>
<tr class="memitem:ae53b57a1e4c19b52ba7dc461c3597a03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1model_1_1rvalue__return.html">rvalue_return</a>&lt; std::vector&lt; T &gt;, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, L &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ae53b57a1e4c19b52ba7dc461c3597a03">rvalue</a> (const std::vector&lt; T &gt; &amp;c, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, L &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:ae53b57a1e4c19b52ba7dc461c3597a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified array with a list of indexes beginning with a single index; the result is determined recursively.  <a href="#ae53b57a1e4c19b52ba7dc461c3597a03">More...</a><br /></td></tr>
<tr class="separator:ae53b57a1e4c19b52ba7dc461c3597a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7fc08e5b6c7caff605985fee19218d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename I , typename L &gt; </td></tr>
<tr class="memitem:a9c7fc08e5b6c7caff605985fee19218d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1model_1_1rvalue__return.html">rvalue_return</a>&lt; std::vector&lt; T &gt;, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, L &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a9c7fc08e5b6c7caff605985fee19218d">rvalue</a> (const std::vector&lt; T &gt; &amp;c, const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, L &gt; &amp;idx, const char *name=&quot;ANON&quot;, int depth=0)</td></tr>
<tr class="memdesc:a9c7fc08e5b6c7caff605985fee19218d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of indexing the specified array with a list of indexes beginning with a multiple index; the result is determined recursively.  <a href="#a9c7fc08e5b6c7caff605985fee19218d">More...</a><br /></td></tr>
<tr class="separator:a9c7fc08e5b6c7caff605985fee19218d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b99009099f8eff7e86da4b0b0bc184d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a4b99009099f8eff7e86da4b0b0bc184d">rvalue_at</a> (int n, const <a class="el" href="structstan_1_1model_1_1index__multi.html">index_multi</a> &amp;idx)</td></tr>
<tr class="memdesc:a4b99009099f8eff7e86da4b0b0bc184d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index in the underlying array corresponding to the specified position in the specified multi-index.  <a href="#a4b99009099f8eff7e86da4b0b0bc184d">More...</a><br /></td></tr>
<tr class="separator:a4b99009099f8eff7e86da4b0b0bc184d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac059d4b0b6f04f4db383b6cafbda72e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ac059d4b0b6f04f4db383b6cafbda72e6">rvalue_at</a> (int n, const <a class="el" href="structstan_1_1model_1_1index__omni.html">index_omni</a> &amp;idx)</td></tr>
<tr class="memdesc:ac059d4b0b6f04f4db383b6cafbda72e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index in the underlying array corresponding to the specified position in the specified omni-index.  <a href="#ac059d4b0b6f04f4db383b6cafbda72e6">More...</a><br /></td></tr>
<tr class="separator:ac059d4b0b6f04f4db383b6cafbda72e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f5e1bec5c254159382af9059a4e55a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a78f5e1bec5c254159382af9059a4e55a">rvalue_at</a> (int n, const <a class="el" href="structstan_1_1model_1_1index__min.html">index_min</a> &amp;idx)</td></tr>
<tr class="memdesc:a78f5e1bec5c254159382af9059a4e55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index in the underlying array corresponding to the specified position in the specified min-index.  <a href="#a78f5e1bec5c254159382af9059a4e55a">More...</a><br /></td></tr>
<tr class="separator:a78f5e1bec5c254159382af9059a4e55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91043a1912f743817da1fb045b64d8bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a91043a1912f743817da1fb045b64d8bd">rvalue_at</a> (int n, const <a class="el" href="structstan_1_1model_1_1index__max.html">index_max</a> &amp;idx)</td></tr>
<tr class="memdesc:a91043a1912f743817da1fb045b64d8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index in the underlying array corresponding to the specified position in the specified max-index.  <a href="#a91043a1912f743817da1fb045b64d8bd">More...</a><br /></td></tr>
<tr class="separator:a91043a1912f743817da1fb045b64d8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc6490be87526fc104307a30dfc25ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a8dc6490be87526fc104307a30dfc25ba">rvalue_at</a> (int n, const <a class="el" href="structstan_1_1model_1_1index__min__max.html">index_min_max</a> &amp;idx)</td></tr>
<tr class="memdesc:a8dc6490be87526fc104307a30dfc25ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index in the underlying array corresponding to the specified position in the specified min-max-index.  <a href="#a8dc6490be87526fc104307a30dfc25ba">More...</a><br /></td></tr>
<tr class="separator:a8dc6490be87526fc104307a30dfc25ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e9768b04dea4a7770f70ef8d50b235"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a15e9768b04dea4a7770f70ef8d50b235">rvalue_index_size</a> (const <a class="el" href="structstan_1_1model_1_1index__multi.html">index_multi</a> &amp;idx, int size)</td></tr>
<tr class="memdesc:a15e9768b04dea4a7770f70ef8d50b235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of specified multi-index.  <a href="#a15e9768b04dea4a7770f70ef8d50b235">More...</a><br /></td></tr>
<tr class="separator:a15e9768b04dea4a7770f70ef8d50b235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa602002b1d095143bbba8ad495b70de4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aa602002b1d095143bbba8ad495b70de4">rvalue_index_size</a> (const <a class="el" href="structstan_1_1model_1_1index__omni.html">index_omni</a> &amp;idx, int size)</td></tr>
<tr class="memdesc:aa602002b1d095143bbba8ad495b70de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of specified omni-index for specified size of input.  <a href="#aa602002b1d095143bbba8ad495b70de4">More...</a><br /></td></tr>
<tr class="separator:aa602002b1d095143bbba8ad495b70de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab172a5c73066c0e3c7aefca200f4f6e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ab172a5c73066c0e3c7aefca200f4f6e1">rvalue_index_size</a> (const <a class="el" href="structstan_1_1model_1_1index__min.html">index_min</a> &amp;idx, int size)</td></tr>
<tr class="memdesc:ab172a5c73066c0e3c7aefca200f4f6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of specified min index for specified size of input.  <a href="#ab172a5c73066c0e3c7aefca200f4f6e1">More...</a><br /></td></tr>
<tr class="separator:ab172a5c73066c0e3c7aefca200f4f6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62bf6e199b41691fe24525773055ee6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ad62bf6e199b41691fe24525773055ee6">rvalue_index_size</a> (const <a class="el" href="structstan_1_1model_1_1index__max.html">index_max</a> &amp;idx, int size)</td></tr>
<tr class="memdesc:ad62bf6e199b41691fe24525773055ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of specified max index.  <a href="#ad62bf6e199b41691fe24525773055ee6">More...</a><br /></td></tr>
<tr class="separator:ad62bf6e199b41691fe24525773055ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aa85ea91a2afb1837f7d0711749ad2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ae0aa85ea91a2afb1837f7d0711749ad2">rvalue_index_size</a> (const <a class="el" href="structstan_1_1model_1_1index__min__max.html">index_min_max</a> &amp;idx, int size)</td></tr>
<tr class="memdesc:ae0aa85ea91a2afb1837f7d0711749ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of specified min-max index.  <a href="#ae0aa85ea91a2afb1837f7d0711749ad2">More...</a><br /></td></tr>
<tr class="separator:ae0aa85ea91a2afb1837f7d0711749ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f75ba8738a5667a7abaef3871e14ca8"><td class="memTemplParams" colspan="2">template&lt;bool jacobian_adjust_transform, class M &gt; </td></tr>
<tr class="memitem:a4f75ba8738a5667a7abaef3871e14ca8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a4f75ba8738a5667a7abaef3871e14ca8">log_prob_propto</a> (const M &amp;model, std::vector&lt; double &gt; &amp;params_r, std::vector&lt; int &gt; &amp;params_i, std::ostream *msgs=0)</td></tr>
<tr class="memdesc:a4f75ba8738a5667a7abaef3871e14ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate log probability for <code>double</code> scalars up to a proportion.  <a href="#a4f75ba8738a5667a7abaef3871e14ca8">More...</a><br /></td></tr>
<tr class="separator:a4f75ba8738a5667a7abaef3871e14ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad33e9d6c10b589acbe6e527b5f9de80"><td class="memTemplParams" colspan="2">template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </td></tr>
<tr class="memitem:aad33e9d6c10b589acbe6e527b5f9de80"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aad33e9d6c10b589acbe6e527b5f9de80">log_prob_grad</a> (const M &amp;model, std::vector&lt; double &gt; &amp;params_r, std::vector&lt; int &gt; &amp;params_i, std::vector&lt; double &gt; &amp;<a class="el" href="namespacestan_1_1model.html#ab4e546deccf701b0255fc6ffee22848c">gradient</a>, std::ostream *msgs=0)</td></tr>
<tr class="memdesc:aad33e9d6c10b589acbe6e527b5f9de80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient using reverse-mode automatic differentiation, writing the result into the specified gradient, using the specified perturbation.  <a href="#aad33e9d6c10b589acbe6e527b5f9de80">More...</a><br /></td></tr>
<tr class="separator:aad33e9d6c10b589acbe6e527b5f9de80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0267095f157269950cfd3f1f402abe21"><td class="memTemplParams" colspan="2">template&lt;bool jacobian_adjust_transform, class M &gt; </td></tr>
<tr class="memitem:a0267095f157269950cfd3f1f402abe21"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a0267095f157269950cfd3f1f402abe21">log_prob_propto</a> (const M &amp;model, Eigen::VectorXd &amp;params_r, std::ostream *msgs=0)</td></tr>
<tr class="memdesc:a0267095f157269950cfd3f1f402abe21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate log probability for <code>double</code> scalars up to a proportion.  <a href="#a0267095f157269950cfd3f1f402abe21">More...</a><br /></td></tr>
<tr class="separator:a0267095f157269950cfd3f1f402abe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bbac348a197c17f86d57cc3a65e7d2"><td class="memTemplParams" colspan="2">template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </td></tr>
<tr class="memitem:aa8bbac348a197c17f86d57cc3a65e7d2"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aa8bbac348a197c17f86d57cc3a65e7d2">log_prob_grad</a> (const M &amp;model, Eigen::VectorXd &amp;params_r, Eigen::VectorXd &amp;<a class="el" href="namespacestan_1_1model.html#ab4e546deccf701b0255fc6ffee22848c">gradient</a>, std::ostream *msgs=0)</td></tr>
<tr class="memdesc:aa8bbac348a197c17f86d57cc3a65e7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient using reverse-mode automatic differentiation, writing the result into the specified gradient, using the specified perturbation.  <a href="#aa8bbac348a197c17f86d57cc3a65e7d2">More...</a><br /></td></tr>
<tr class="separator:aa8bbac348a197c17f86d57cc3a65e7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2660b5de2ccd8322d61f077d43289d18"><td class="memTemplParams" colspan="2">template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </td></tr>
<tr class="memitem:a2660b5de2ccd8322d61f077d43289d18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a2660b5de2ccd8322d61f077d43289d18">finite_diff_grad</a> (const M &amp;model, std::vector&lt; double &gt; &amp;params_r, std::vector&lt; int &gt; &amp;params_i, std::vector&lt; double &gt; &amp;grad, double epsilon=1e-6, std::ostream *msgs=0)</td></tr>
<tr class="memdesc:a2660b5de2ccd8322d61f077d43289d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient using finite differences for the specified parameters, writing the result into the specified gradient, using the specified perturbation.  <a href="#a2660b5de2ccd8322d61f077d43289d18">More...</a><br /></td></tr>
<tr class="separator:a2660b5de2ccd8322d61f077d43289d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb110f72ea848114cd4321b3ea554e15"><td class="memTemplParams" colspan="2">template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </td></tr>
<tr class="memitem:aeb110f72ea848114cd4321b3ea554e15"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#aeb110f72ea848114cd4321b3ea554e15">test_gradients</a> (const M &amp;model, std::vector&lt; double &gt; &amp;params_r, std::vector&lt; int &gt; &amp;params_i, double epsilon, double error, std::ostream &amp;o, std::ostream *msgs)</td></tr>
<tr class="memdesc:aeb110f72ea848114cd4321b3ea554e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the <a class="el" href="namespacestan_1_1model.html#aad33e9d6c10b589acbe6e527b5f9de80" title="Compute the gradient using reverse-mode automatic differentiation, writing the result into the specif...">log_prob_grad()</a> function's ability to produce accurate gradients using finite differences.  <a href="#aeb110f72ea848114cd4321b3ea554e15">More...</a><br /></td></tr>
<tr class="separator:aeb110f72ea848114cd4321b3ea554e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83f35a2e6e0b78d505d8128dee49588"><td class="memTemplParams" colspan="2">template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </td></tr>
<tr class="memitem:ad83f35a2e6e0b78d505d8128dee49588"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ad83f35a2e6e0b78d505d8128dee49588">grad_hess_log_prob</a> (const M &amp;model, std::vector&lt; double &gt; &amp;params_r, std::vector&lt; int &gt; &amp;params_i, std::vector&lt; double &gt; &amp;<a class="el" href="namespacestan_1_1model.html#ab4e546deccf701b0255fc6ffee22848c">gradient</a>, std::vector&lt; double &gt; &amp;<a class="el" href="namespacestan_1_1model.html#a060489d342b8fd3139e7df33b4a01170">hessian</a>, std::ostream *msgs=0)</td></tr>
<tr class="memdesc:ad83f35a2e6e0b78d505d8128dee49588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the log-probability, its gradient, and its Hessian at params_r.  <a href="#ad83f35a2e6e0b78d505d8128dee49588">More...</a><br /></td></tr>
<tr class="separator:ad83f35a2e6e0b78d505d8128dee49588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e546deccf701b0255fc6ffee22848c"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ab4e546deccf701b0255fc6ffee22848c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ab4e546deccf701b0255fc6ffee22848c">gradient</a> (const M &amp;model, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, double &amp;f, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;grad_f, std::ostream *msgs=0)</td></tr>
<tr class="separator:ab4e546deccf701b0255fc6ffee22848c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060489d342b8fd3139e7df33b4a01170"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a060489d342b8fd3139e7df33b4a01170"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a060489d342b8fd3139e7df33b4a01170">hessian</a> (const M &amp;model, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, double &amp;f, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;grad_f, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;hess_f, std::ostream *msgs=0)</td></tr>
<tr class="separator:a060489d342b8fd3139e7df33b4a01170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbd2cae4a29ea16ebe9c60597d2d84e"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a3fbd2cae4a29ea16ebe9c60597d2d84e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a3fbd2cae4a29ea16ebe9c60597d2d84e">gradient_dot_vector</a> (const M &amp;model, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;v, double &amp;f, double &amp;grad_f_dot_v, std::ostream *msgs=0)</td></tr>
<tr class="separator:a3fbd2cae4a29ea16ebe9c60597d2d84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b836ad2524ecb1b50f465d6305f88d2"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a2b836ad2524ecb1b50f465d6305f88d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#a2b836ad2524ecb1b50f465d6305f88d2">hessian_times_vector</a> (const M &amp;model, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;v, double &amp;f, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;hess_f_dot_v, std::ostream *msgs=0)</td></tr>
<tr class="separator:a2b836ad2524ecb1b50f465d6305f88d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f018a163d9dc97339f88d82664ce73"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ac9f018a163d9dc97339f88d82664ce73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1model.html#ac9f018a163d9dc97339f88d82664ce73">grad_tr_mat_times_hessian</a> (const M &amp;model, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;X, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;grad_tr_X_hess_f, std::ostream *msgs=0)</td></tr>
<tr class="separator:ac9f018a163d9dc97339f88d82664ce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>For compiling models. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7f0b8ef16725f1195f73e08e116017e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified scalar reference under the specified indexing to the specified scalar value. </p>
<p>Types: x[] &lt;- y</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Assigned variable type. </td></tr>
    <tr><td class="paramname">U</td><td>Value type (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00033">33</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f71b06cde1e977368b20d1d400c6480"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified Eigen vector at the specified single index to the specified value. </p>
<p>Types: vec[uni] &lt;- scalar</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of assigned vector scalar. </td></tr>
    <tr><td class="paramname">U</td><td>Type of value (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Sequence of one single index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the index is out of bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00054">54</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d30982b96914bc5b95cc8089f2ce565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified Eigen vector at the specified single index to the specified value. </p>
<p>Types: row_vec[uni] &lt;- scalar</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of assigned row vector scalar. </td></tr>
    <tr><td class="paramname">U</td><td>Type of value (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Row vector variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Sequence of one single index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Index is out of bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00079">79</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8bb876f8c3abde7ff2bdeb5038c43d6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, void&gt;::type stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; U, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified Eigen vector at the specified multiple index to the specified value. </p>
<p>Types: vec[multi] &lt;- vec</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of assigned vector scalar. </td></tr>
    <tr><td class="paramname">I</td><td>Type of multiple index. </td></tr>
    <tr><td class="paramname">U</td><td>Type of vector value scalar (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Row vector variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Sequence of one single index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If any of the indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>If the value size isn't the same as the indexed size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00108">108</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9490a4a5e36acddfc2384825ecb9721b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, void&gt;::type stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; U, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified Eigen row vector at the specified multiple index to the specified value. </p>
<p>Types: row_vec[multi] &lt;- row_vec</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type for assigned row vector. </td></tr>
    <tr><td class="paramname">I</td><td>Type of multiple index. </td></tr>
    <tr><td class="paramname">U</td><td>Type of value row vector scalar (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Row vector variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Sequence of one multiple index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If any of the indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>If the value size isn't the same as the indexed size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00142">142</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b732d3abb2cb830e460b511e738a3cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; U, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the specified Eigen matrix at the specified single index to the specified row vector value. </p>
<p>Types: mat[uni] = rowvec</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Assigned matrix scalar type. </td></tr>
    <tr><td class="paramname">U</td><td>Type of value scalar for row vector (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Matrix variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Sequence of one single index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value row vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If any of the indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>If the number of columns in the row vector and matrix do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00175">175</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07159284d6272c14cdb5509c616cdad8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, void&gt;::type stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; U, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified Eigen matrix at the specified multiple index to the specified matrix value. </p>
<p>Types: mat[multi] = mat</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Assigned matrix scalar type. </td></tr>
    <tr><td class="paramname">I</td><td>Multiple index type. </td></tr>
    <tr><td class="paramname">U</td><td>Value matrix scalar type (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Matrix variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Sequence of one multiple index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If any of the indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>If the dimensions of the indexed matrix and right-hand side matrix do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00205">205</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a230e918a853477b72dc274d20467a6c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the specified Eigen matrix at the specified pair of single indexes to the specified scalar value. </p>
<p>Types: mat[single, single] = scalar</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Matrix scalar type. </td></tr>
    <tr><td class="paramname">U</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Matrix variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Sequence of two single indexes (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value scalar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If either of the indices are out of bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00237">237</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3003870fefbc179d776ea3207d14f12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, void&gt;::type stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; U, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified Eigen matrix at the specified single and multiple index to the specified row vector. </p>
<p>Types: mat[uni, multi] = rowvec</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Assigned matrix scalar type. </td></tr>
    <tr><td class="paramname">I</td><td>Multi-index type. </td></tr>
    <tr><td class="paramname">U</td><td>Value row vector scalar type (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Matrix variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Sequence of single and multiple index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value row vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If any of the indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>If the dimensions of the indexed matrix and right-hand side row vector do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00271">271</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56779293f41b1efa31c8da32e2b0f9b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, void&gt;::type stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; U, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified Eigen matrix at the specified multiple and single index to the specified vector. </p>
<p>Types: mat[multi, uni] = vec</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Assigned matrix scalar type. </td></tr>
    <tr><td class="paramname">I</td><td>Multi-index type. </td></tr>
    <tr><td class="paramname">U</td><td>Value vector scalar type (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Matrix variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Sequence of multiple and single index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If any of the indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>If the dimensions of the indexed matrix and right-hand side vector do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00308">308</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9f637db1c94e950ba4642ba2c46afb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I1 , typename I2 , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if_c&lt;boost::is_same&lt;I1, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;::value || boost::is_same&lt;I2, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;::value, void&gt;::type stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I1, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I2, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; U, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified Eigen matrix at the specified pair of multiple indexes to the specified matrix. </p>
<p>Types: mat[multi, multi] = mat</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Assigned matrix scalar type. </td></tr>
    <tr><td class="paramname">I1</td><td>First multiple index type. </td></tr>
    <tr><td class="paramname">I2</td><td>Second multiple index type. </td></tr>
    <tr><td class="paramname">U</td><td>Value matrix scalar type (must be assignable to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Matrix variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>Pair of multiple indexes (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If any of the indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>If the dimensions of the indexed matrix and value matrix do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00349">349</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3916ad65b7d9d8e0972fb63860f7013d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename L , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, L &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified array (standard vector) at the specified index list beginning with a single index to the specified value. </p>
<p>This function operates recursively to carry out the tail indexing.</p>
<p>Types: x[uni | L] = y</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Assigned vector member type. </td></tr>
    <tr><td class="paramname">L</td><td>Type of tail of index list. </td></tr>
    <tr><td class="paramname">U</td><td>Value scalar type (must be assignable to indexed variable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Array variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>List of indexes beginning with single index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If any of the indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>If the dimensions do not match in the tail assignment. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00397">397</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ec6a7e4faad53ff63e31850bccd8fcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I , typename L , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, void&gt;::type stan::model::assign </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, L &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the specified array (standard vector) at the specified index list beginning with a multiple index to the specified value. </p>
<p>This function operates recursively to carry out the tail indexing.</p>
<p>Types: x[multi | L] = y</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Assigned vector member type. </td></tr>
    <tr><td class="paramname">I</td><td>Type of multiple index heading index list. </td></tr>
    <tr><td class="paramname">L</td><td>Type of tail of index list. </td></tr>
    <tr><td class="paramname">U</td><td>Value scalar type (must be assignable to indexed variable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Array variable to be assigned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>List of indexes beginning with multiple index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of variable (default "ANON"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Indexing depth (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If any of the indices are out of bounds. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>If the size of the multiple indexing and size of first dimension of value do not match, or any of the recursive tail assignment dimensions do not match. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lvalue_8hpp_source.html#l00432">432</a> of file <a class="el" href="lvalue_8hpp_source.html">lvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a278284087b9a82fd76dd8f6b78a262d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt;I, T&gt; stan::model::cons_list </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="index__list_8hpp_source.html#l00043">43</a> of file <a class="el" href="index__list_8hpp_source.html">index_list.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6084abaf50ba3f9fbc1e0a7461d85319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::model::deep_copy </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the specified argument as a constant reference. </p>
<p>Warning: because of the usage pattern of this class, this function only needs to return value references, not actual copies. The functions that call this overload recursively will be doing the actual copies with assignment.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant reference to input. </dd></dl>

<p>Definition at line <a class="el" href="deep__copy_8hpp_source.html#l00024">24</a> of file <a class="el" href="deep__copy_8hpp_source.html">deep_copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a85308234fda43fcf61b398887e12e3de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int R, int C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R, C&gt; stan::model::deep_copy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, R, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the specified matrix, vector, or row vector. </p>
<p>The return value is a copy in the sense that modifying its contents will not affect the original matrix.</p>
<p>Warning: This function assumes that the elements of the matrix deep copy under assignment.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">R</td><td>Row type specificiation. </td></tr>
    <tr><td class="paramname">C</td><td>Column type specificiation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input matrix, vector, or row vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deep copy of input. </dd></dl>

<p>Definition at line <a class="el" href="deep__copy_8hpp_source.html#l00043">43</a> of file <a class="el" href="deep__copy_8hpp_source.html">deep_copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3dd9a8c2e34a21493d17e4c911dac16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::model::deep_copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a deep copy of the specified standard vector. </p>
<p>The return value is a copy in the sense that modifying its contents will not affect the original vector.</p>
<p>Warning: This function assumes that the elements of the vector deep copy under assignment.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Deep copy of input. </dd></dl>

<p>Definition at line <a class="el" href="deep__copy_8hpp_source.html#l00061">61</a> of file <a class="el" href="deep__copy_8hpp_source.html">deep_copy.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2660b5de2ccd8322d61f077d43289d18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::finite_diff_grad </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient using finite differences for the specified parameters, writing the result into the specified gradient, using the specified perturbation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculation is up to proportion (double-only terms dropped). </td></tr>
    <tr><td class="paramname">jacobian_adjust_transform</td><td>True if the log absolute Jacobian determinant of inverse parameter transforms is added to the log probability. </td></tr>
    <tr><td class="paramname">M</td><td>Class of model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">model</td><td>Model. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params_r</td><td>Real-valued parameters. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params_i</td><td>Integer-valued parameters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad</td><td>Vector into which gradient is written. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">epsilon</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msgs</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00227">227</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad83f35a2e6e0b78d505d8128dee49588"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::model::grad_hess_log_prob </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>hessian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the log-probability, its gradient, and its Hessian at params_r. </p>
<p>This default version computes the Hessian numerically by finite-differencing the gradient, at a cost of O(params_r.size()^2).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculation is up to proportion (double-only terms dropped). </td></tr>
    <tr><td class="paramname">jacobian_adjust_transform</td><td>True if the log absolute Jacobian determinant of inverse parameter transforms is added to the log probability. </td></tr>
    <tr><td class="paramname">M</td><td>Class of model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>Model. </td></tr>
    <tr><td class="paramname">params_r</td><td>Real-valued parameter vector. </td></tr>
    <tr><td class="paramname">params_i</td><td>Integer-valued parameter vector. </td></tr>
    <tr><td class="paramname">gradient</td><td>Vector to write gradient to. </td></tr>
    <tr><td class="paramname">hessian</td><td>Vector to write gradient to. hessian[i*D + j] gives the element at the ith row and jth column of the Hessian (where D=params_r.size()). </td></tr>
    <tr><td class="paramname">msgs</td><td>Stream to which print statements in Stan programs are written, default is 0 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00351">351</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9f018a163d9dc97339f88d82664ce73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::grad_tr_mat_times_hessian </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_tr_X_hess_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00455">455</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4e546deccf701b0255fc6ffee22848c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::gradient </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00412">412</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3fbd2cae4a29ea16ebe9c60597d2d84e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::gradient_dot_vector </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>grad_f_dot_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00432">432</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a060489d342b8fd3139e7df33b4a01170"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::hessian </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>hess_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00421">421</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b836ad2524ecb1b50f465d6305f88d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stan::model::hessian_times_vector </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>hess_f_dot_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00443">443</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43c059a1718ccb6220b7f04d87cb6c81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> stan::model::index_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="index__list_8hpp_source.html#l00048">48</a> of file <a class="el" href="index__list_8hpp_source.html">index_list.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa97c001e5692ddbc3d49b16e0f15f0c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt;I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a>&gt; stan::model::index_list </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="index__list_8hpp_source.html#l00054">54</a> of file <a class="el" href="index__list_8hpp_source.html">index_list.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f85816f7cdf1ccd08410e136fee1d37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt;I1, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt;I2, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a>&gt; &gt; stan::model::index_list </td>
          <td>(</td>
          <td class="paramtype">const I1 &amp;&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I2 &amp;&#160;</td>
          <td class="paramname"><em>idx2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="index__list_8hpp_source.html#l00060">60</a> of file <a class="el" href="index__list_8hpp_source.html">index_list.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ef6ff4159e0d5ae26c70a531bfdc0af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 , typename I3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt;I1, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt;I2, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt;I3, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a>&gt; &gt; &gt; stan::model::index_list </td>
          <td>(</td>
          <td class="paramtype">const I1 &amp;&#160;</td>
          <td class="paramname"><em>idx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I2 &amp;&#160;</td>
          <td class="paramname"><em>idx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I3 &amp;&#160;</td>
          <td class="paramname"><em>idx3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="index__list_8hpp_source.html#l00070">70</a> of file <a class="el" href="index__list_8hpp_source.html">index_list.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad33e9d6c10b589acbe6e527b5f9de80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::model::log_prob_grad </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient using reverse-mode automatic differentiation, writing the result into the specified gradient, using the specified perturbation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculation is up to proportion (double-only terms dropped). </td></tr>
    <tr><td class="paramname">jacobian_adjust_transform</td><td>True if the log absolute Jacobian determinant of inverse parameter transforms is added to the log probability. </td></tr>
    <tr><td class="paramname">M</td><td>Class of model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>Model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_r</td><td>Real-valued parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_i</td><td>Integer-valued parameters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gradient</td><td>Vector into which gradient is written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msgs</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00091">91</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa8bbac348a197c17f86d57cc3a65e7d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::model::log_prob_grad </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>params_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the gradient using reverse-mode automatic differentiation, writing the result into the specified gradient, using the specified perturbation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculation is up to proportion (double-only terms dropped). </td></tr>
    <tr><td class="paramname">jacobian_adjust_transform</td><td>True if the log absolute Jacobian determinant of inverse parameter transforms is added to the log probability. </td></tr>
    <tr><td class="paramname">M</td><td>Class of model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>Model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_r</td><td>Real-valued parameters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gradient</td><td>Vector into which gradient is written. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msgs</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00182">182</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f75ba8738a5667a7abaef3871e14ca8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool jacobian_adjust_transform, class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::model::log_prob_propto </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate log probability for <code>double</code> scalars up to a proportion. </p>
<p>This implementation wraps the <code>double</code> values in <code>stan::math::var</code> and calls the model's <code>log_prob()</code> function with <code>propto=true</code> and the specified parameter for applying the Jacobian adjustment for transformed parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculation is up to proportion (double-only terms dropped). </td></tr>
    <tr><td class="paramname">jacobian_adjust_transform</td><td>True if the log absolute Jacobian determinant of inverse parameter transforms is added to the log probability. </td></tr>
    <tr><td class="paramname">M</td><td>Class of model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>Model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_r</td><td>Real-valued parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_i</td><td>Integer-valued parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msgs</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00052">52</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0267095f157269950cfd3f1f402abe21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool jacobian_adjust_transform, class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double stan::model::log_prob_propto </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>params_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate log probability for <code>double</code> scalars up to a proportion. </p>
<p>This implementation wraps the <code>double</code> values in <code>stan::math::var</code> and calls the model's <code>log_prob()</code> function with <code>propto=true</code> and the specified parameter for applying the Jacobian adjustment for transformed parameters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculation is up to proportion (double-only terms dropped). </td></tr>
    <tr><td class="paramname">jacobian_adjust_transform</td><td>True if the log absolute Jacobian determinant of inverse parameter transforms is added to the log probability. </td></tr>
    <tr><td class="paramname">M</td><td>Class of model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>Model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params_r</td><td>Real-valued parameters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">msgs</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00139">139</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8c4d8320edab91bdc7872b161bb1590"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing a specified value with a nil index list, which just returns the value. </p>
<p>Types: T[] : T</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Value to index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input value. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00032">32</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa675158b2ee44a54362c2b39cbf59c58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen vector with a sequence containing one single index, returning a scalar. </p>
<p>Types: vec[single] : scal</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector being indexed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>One single index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing vector. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00051">51</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ce39dae68c631e5131ef0e5fc37f97d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen row vector with a sequence containing one single index, returning a scalar. </p>
<p>Types: rowvec[single] : scal</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rv</td><td>Row vector being indexed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>One single index in list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing row vector. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00074">74</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb7eb76075d6d1084507c57872d41827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; &gt;::type stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen vector with a sequence containing one multiple index, returning a vector. </p>
<p>Types: vec[multiple] : vec</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">I</td><td>Multi-index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Eigen vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index consisting of one multi-index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing vector. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00101">101</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa96fa8f4cb88877349ca79caf562404f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; &gt;::type stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen row vector with a sequence containing one multiple index, returning a row vector. </p>
<p>Types: row_vec[multiple] : rowvec</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">I</td><td>Multi-index type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rv</td><td>Eigen row vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index consisting of one multi-index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing vector. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00133">133</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6180f5d0443f3be7a66e60cf5e596bfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen matrix with a sequence consisting of one single index, returning a row vector. </p>
<p>Types: mat[single] : rowvec</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Eigen matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index consisting of one uni-index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing matrix. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00161">161</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af583f433425d3b9f59dc3f7d4d008e51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; &gt;::type stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen matrix with a sequence consisting of a one multiple index, returning a matrix. </p>
<p>Types: mat[multiple] : mat</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">I</td><td>Type of multiple index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Matrix to index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index consisting of single multiple index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing matrix. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00187">187</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9079b2f7194ad6c26a3a6d0de929a7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen matrix with a sequence consisting of two single indexes, returning a scalar. </p>
<p>Types: mat[single,single] : scalar</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Matrix to index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Pair of single indexes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing matrix. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00215">215</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0bc4a3239513de365fa9605d42cdd1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt; &gt;::type stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen matrix with a sequence consisting of a single index and multiple index, returning a row vector. </p>
<p>Types: mat[single,multiple] : row vector</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">I</td><td>Type of multiple index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Matrix to index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Pair of single index and multiple index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing matrix. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00246">246</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7874bb360c679dc3bf53bcb09a3e346"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_same&lt;I, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;, Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; &gt;::type stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen matrix with a sequence consisting of a multiple index and a single index, returning a vector. </p>
<p>Types: mat[multiple,single] : vector</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">I</td><td>Type of multiple index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Matrix to index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Pair multiple index and single index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing matrix. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00275">275</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad62e0fdc3aa8908c0c354f650dbda201"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I1 , typename I2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if_c&lt;boost::is_same&lt;I1, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;::value || boost::is_same&lt;I2, <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>&gt;::value, Eigen::Matrix&lt;T, Eigen::Dynamic, Eigen::Dynamic&gt; &gt;::type stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I1, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I2, <a class="el" href="structstan_1_1model_1_1nil__index__list.html">nil_index_list</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified Eigen matrix with a sequence consisting of a pair o multiple indexes, returning a a matrix. </p>
<p>Types: mat[multiple,multiple] : mat</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
    <tr><td class="paramname">I</td><td>Type of multiple index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Matrix to index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Pair of multiple indexes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing matrix. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00312">312</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae53b57a1e4c19b52ba7dc461c3597a03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1model_1_1rvalue__return.html">rvalue_return</a>&lt;std::vector&lt;T&gt;, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt;<a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, L&gt; &gt;::type stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; <a class="el" href="structstan_1_1model_1_1index__uni.html">index_uni</a>, L &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified array with a list of indexes beginning with a single index; the result is determined recursively. </p>
<p>Note that arrays are represented as standard library vectors.</p>
<p>Types: std::vector&lt;T&gt;[single | L] : T[L]</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of list elements. </td></tr>
    <tr><td class="paramname">L</td><td>Index list type for indexes after first index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Container of list elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index list beginning with single index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing array. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00352">352</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c7fc08e5b6c7caff605985fee19218d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename I , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstan_1_1model_1_1rvalue__return.html">rvalue_return</a>&lt;std::vector&lt;T&gt;, <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt;I, L&gt; &gt;::type stan::model::rvalue </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1cons__index__list.html">cons_index_list</a>&lt; I, L &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ANON&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of indexing the specified array with a list of indexes beginning with a multiple index; the result is determined recursively. </p>
<p>Note that arrays are represented as standard library vectors.</p>
<p>Types: std::vector&lt;T&gt;[multiple | L] : std::vector&lt;T[L]&gt;</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of list elements. </td></tr>
    <tr><td class="paramname">L</td><td>Index list type for indexes after first index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Container of list elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index list beginning with multiple index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String form of expression being evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of indexing dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of indexing array. </dd></dl>

<p>Definition at line <a class="el" href="rvalue_8hpp_source.html#l00377">377</a> of file <a class="el" href="rvalue_8hpp_source.html">rvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b99009099f8eff7e86da4b0b0bc184d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__multi.html">index_multi</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index in the underlying array corresponding to the specified position in the specified multi-index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Relative index position (from 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index (from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying index position (from 1). </dd></dl>

<p>Definition at line <a class="el" href="rvalue__at_8hpp_source.html#l00021">21</a> of file <a class="el" href="rvalue__at_8hpp_source.html">rvalue_at.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac059d4b0b6f04f4db383b6cafbda72e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__omni.html">index_omni</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index in the underlying array corresponding to the specified position in the specified omni-index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Relative index position (from 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index (from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying index position (from 1). </dd></dl>

<p>Definition at line <a class="el" href="rvalue__at_8hpp_source.html#l00033">33</a> of file <a class="el" href="rvalue__at_8hpp_source.html">rvalue_at.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78f5e1bec5c254159382af9059a4e55a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__min.html">index_min</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index in the underlying array corresponding to the specified position in the specified min-index. </p>
<p>All indexing begins from 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Relative index position (from 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index (from 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying index position (from 1). </dd></dl>

<p>Definition at line <a class="el" href="rvalue__at_8hpp_source.html#l00047">47</a> of file <a class="el" href="rvalue__at_8hpp_source.html">rvalue_at.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91043a1912f743817da1fb045b64d8bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__max.html">index_max</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index in the underlying array corresponding to the specified position in the specified max-index. </p>
<p>All indexing begins from 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Relative index position (from 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index (from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying index position (from 1). </dd></dl>

<p>Definition at line <a class="el" href="rvalue__at_8hpp_source.html#l00061">61</a> of file <a class="el" href="rvalue__at_8hpp_source.html">rvalue_at.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8dc6490be87526fc104307a30dfc25ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__min__max.html">index_min_max</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index in the underlying array corresponding to the specified position in the specified min-max-index. </p>
<p>All indexing begins from 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Relative index position (from 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index (from 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying index position (from 1). </dd></dl>

<p>Definition at line <a class="el" href="rvalue__at_8hpp_source.html#l00075">75</a> of file <a class="el" href="rvalue__at_8hpp_source.html">rvalue_at.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15e9768b04dea4a7770f70ef8d50b235"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_index_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__multi.html">index_multi</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size of specified multi-index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Input index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of container (ignored here). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of result. </dd></dl>

<p>Definition at line <a class="el" href="rvalue__index__size_8hpp_source.html#l00019">19</a> of file <a class="el" href="rvalue__index__size_8hpp_source.html">rvalue_index_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa602002b1d095143bbba8ad495b70de4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_index_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__omni.html">index_omni</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size of specified omni-index for specified size of input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Input index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of result. </dd></dl>

<p>Definition at line <a class="el" href="rvalue__index__size_8hpp_source.html#l00031">31</a> of file <a class="el" href="rvalue__index__size_8hpp_source.html">rvalue_index_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab172a5c73066c0e3c7aefca200f4f6e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_index_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__min.html">index_min</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size of specified min index for specified size of input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Input index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of result. </dd></dl>

<p>Definition at line <a class="el" href="rvalue__index__size_8hpp_source.html#l00043">43</a> of file <a class="el" href="rvalue__index__size_8hpp_source.html">rvalue_index_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad62bf6e199b41691fe24525773055ee6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_index_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__max.html">index_max</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size of specified max index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Input index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of container (ignored). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of result. </dd></dl>

<p>Definition at line <a class="el" href="rvalue__index__size_8hpp_source.html#l00054">54</a> of file <a class="el" href="rvalue__index__size_8hpp_source.html">rvalue_index_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0aa85ea91a2afb1837f7d0711749ad2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::rvalue_index_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstan_1_1model_1_1index__min__max.html">index_min_max</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size of specified min-max index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Input index (from 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of container (ignored). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of result. </dd></dl>

<p>Definition at line <a class="el" href="rvalue__index__size_8hpp_source.html#l00065">65</a> of file <a class="el" href="rvalue__index__size_8hpp_source.html">rvalue_index_size.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb110f72ea848114cd4321b3ea554e15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, bool jacobian_adjust_transform, class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int stan::model::test_gradients </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>params_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>msgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the <a class="el" href="namespacestan_1_1model.html#aad33e9d6c10b589acbe6e527b5f9de80" title="Compute the gradient using reverse-mode automatic differentiation, writing the result into the specif...">log_prob_grad()</a> function's ability to produce accurate gradients using finite differences. </p>
<p>This shouldn't be necessary when using autodiff, but is useful for finding bugs in hand-written code (or var).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">propto</td><td>True if calculation is up to proportion (double-only terms dropped). </td></tr>
    <tr><td class="paramname">jacobian_adjust_transform</td><td>True if the log absolute Jacobian determinant of inverse parameter transforms is added to the log probability. </td></tr>
    <tr><td class="paramname">M</td><td>Class of model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>Model. </td></tr>
    <tr><td class="paramname">params_r</td><td>Real-valued parameter vector. </td></tr>
    <tr><td class="paramname">params_i</td><td>Integer-valued parameter vector. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Real-valued scalar saying how much to perturb. Reasonable value is 1e-6. </td></tr>
    <tr><td class="paramname">error</td><td>Real-valued scalar saying how much error to allow. Reasonable value is 1e-6. </td></tr>
    <tr><td class="paramname">o</td><td>Output stream for messages. </td></tr>
    <tr><td class="paramname">msgs</td><td>Stream to which Stan programs write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of failed gradient comparisons versus allowed error, so 0 if all gradients pass </dd></dl>

<p>Definition at line <a class="el" href="model_2util_8hpp_source.html#l00278">278</a> of file <a class="el" href="model_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr/>
<div class="conents" style="font-size:80%;">
  <span style="float:left; margin=0 1em 0 1em;">
  &nbsp;&nbsp;&nbsp;&nbsp;
  [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
  </span>
  <span style="float:right; margin=0 1em 0 1em;">
  <i>&copy; 2011&ndash;2015,
  Stan Development Team.
  &nbsp;&nbsp;&nbsp;&nbsp;
  </i>
  </span>
</div>
